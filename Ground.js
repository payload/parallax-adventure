// Generated by CoffeeScript 1.3.1
(function() {
  var Ground,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Ground = (function() {

    Ground.name = 'Ground';

    function Ground(_arg) {
      var i, slope, step_size, steps, x1, x2, y1, y2, _ref;
      _ref = _arg != null ? _arg : {}, this.p = _ref.p, this.size = _ref.size;
      this.draw_ground = __bind(this.draw_ground, this);

      this.draw = __bind(this.draw, this);

      this.top = __bind(this.top, this);

      if (this.p == null) {
        this.p = v(0, 0);
      }
      if (this.size == null) {
        this.size = v(100, 100);
      }
      steps = Math.floor(this.size.x / 25);
      step_size = this.size.x / steps;
      y2 = this.size.y / 2 + random0(this.size.y / 2);
      this.tops = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= steps ? _i < steps : _i > steps; i = 0 <= steps ? ++_i : --_i) {
          x1 = i * step_size;
          y1 = y2;
          x2 = x1 + step_size;
          y2 = max(min(y1 + random0(this.size.y / 2), this.size.y), 0);
          slope = (y2 - y1) / step_size;
          _results.push({
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            slope: slope
          });
        }
        return _results;
      }).call(this);
      this.changed = false;
    }

    Ground.prototype.top = function(x) {
      var i, top, _i, _len, _ref;
      _ref = this.tops;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        top = _ref[i];
        if ((this.p.x + top.x1 <= x && x <= this.p.x + top.x2)) {
          return this.p.y + top.y1 + top.slope * (x - top.x1 - this.p.x);
        }
      }
      return this.p.y;
    };

    Ground.prototype.draw = function(ctx) {
      ctx.save();
      ctx.translate(this.p.x, this.p.y);
      this.draw_ground(ctx);
      return ctx.restore();
    };

    Ground.prototype.draw_ground = function(ctx) {
      var top, _i, _len, _ref;
      ctx.save();
      ctx.beginPath();
      top = this.tops[0];
      ctx.moveTo(top.x1, top.y1);
      _ref = this.tops;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        top = _ref[_i];
        ctx.lineTo(top.x2, top.y2);
      }
      ctx.stroke();
      return ctx.restore();
    };

    Ground.prototype.update = function(dt) {};

    return Ground;

  })();

  window.Ground = Ground;

}).call(this);
